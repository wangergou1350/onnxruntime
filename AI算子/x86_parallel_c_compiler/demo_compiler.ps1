#!/usr/bin/env powershell
# X86/X64 并行 C 编译器演示脚本
# 由于缺少 C 编译器，此脚本展示编译器的功能和生成的汇编代码

param(
    [string]$InputFile,
    [string]$OutputFile = "",
    [switch]$Verbose,
    [switch]$Help,
    [string]$OptLevel = "0",
    [switch]$OpenMP,
    [switch]$Vectorize
)

$ErrorActionPreference = "Stop"

function Show-Help {
    Write-Host "X86/X64 Parallel C Compiler (Demo Version)" -ForegroundColor Yellow
    Write-Host "===========================================" -ForegroundColor Yellow
    Write-Host ""
    Write-Host "Usage: .\demo_compiler.ps1 [options] <input_file>"
    Write-Host ""
    Write-Host "Options:"
    Write-Host "  -InputFile <file>     Input C source file"
    Write-Host "  -OutputFile <file>    Output assembly file"
    Write-Host "  -Verbose              Show detailed output"
    Write-Host "  -Help                 Show this help"
    Write-Host "  -OptLevel <0-3>       Optimization level"
    Write-Host "  -OpenMP               Enable parallel processing"
    Write-Host "  -Vectorize            Enable vectorization"
    Write-Host ""
    Write-Host "Examples:"
    Write-Host "  .\demo_compiler.ps1 -InputFile examples\basic.c"
    Write-Host "  .\demo_compiler.ps1 -InputFile examples\parallel.c -OpenMP -Verbose"
}

function Get-SourceAnalysis {
    param([string]$FilePath)
    
    if (-not (Test-Path $FilePath)) {
        throw "Input file not found: $FilePath"
    }
    
    $content = Get-Content $FilePath -Raw
    $analysis = @{
        HasMain = $content -match "int\s+main\s*\("
        HasFunctions = $content -match "\w+\s+\w+\s*\([^)]*\)\s*\{"
        HasLoops = $content -match "(for|while)\s*\("
        HasParallelFor = $content -match "parallel_for\s*\("
        HasAtomic = $content -match "atomic\s+"
        HasCritical = $content -match "critical\s*\{"
        HasArrays = $content -match "\[\s*\d*\s*\]"
        HasPointers = $content -match "\*\s*\w+"
        LineCount = ($content -split "\n").Count
        Functions = @()
        Variables = @()
    }
    
    # 提取函数
    $functionMatches = [regex]::Matches($content, "(\w+)\s+(\w+)\s*\([^)]*\)\s*\{")
    foreach ($match in $functionMatches) {
        $analysis.Functions += @{
            ReturnType = $match.Groups[1].Value
            Name = $match.Groups[2].Value
        }
    }
    
    # 提取变量声明
    $varMatches = [regex]::Matches($content, "(int|float|double|char)\s+(\w+)")
    foreach ($match in $varMatches) {
        $analysis.Variables += @{
            Type = $match.Groups[1].Value
            Name = $match.Groups[2].Value
        }
    }
    
    return $analysis
}

function New-AssemblyCode {
    param(
        [hashtable]$Analysis,
        [string]$OptLevel,
        [bool]$EnableParallel,
        [bool]$EnableVectorize
    )
    
    $asm = @"
# X86/X64 Assembly Code Generated by Parallel C Compiler
# Target: x86_64-pc-linux-gnu
# Optimization Level: O$OptLevel
# Parallel Processing: $(if ($EnableParallel) { 'Enabled' } else { 'Disabled' })
# Vectorization: $(if ($EnableVectorize) { 'Enabled' } else { 'Disabled' })

.section .text
.globl main

"@

    if ($Analysis.HasMain) {
        $asm += @"

# Main function
main:
    pushq   %rbp                # Function prologue
    movq    %rsp, %rbp          # Set up stack frame
    subq    `$16, %rsp          # Allocate local variables

"@
    }

    foreach ($func in $Analysis.Functions) {
        if ($func.Name -ne "main") {
            $asm += @"

# Function: $($func.ReturnType) $($func.Name)()
$($func.Name):
    pushq   %rbp
    movq    %rsp, %rbp
    # Function body would be generated here
    popq    %rbp
    ret

"@
        }
    }

    if ($Analysis.HasLoops) {
        $asm += @"
    # Loop implementation
.L_loop_start:
    movl    -4(%rbp), %eax      # Load loop variable
    cmpl    `$10, %eax          # Compare with limit
    jge     .L_loop_end         # Jump if greater or equal
    
    # Loop body
    incl    -4(%rbp)            # Increment counter
    jmp     .L_loop_start       # Jump back to start
    
.L_loop_end:

"@
    }

    if ($Analysis.HasParallelFor -and $EnableParallel) {
        $asm += @"
    # Parallel for loop implementation
    movl    `$4, %edi           # Number of threads
    call    omp_set_num_threads # Set thread count
    
    # Parallel region setup
    movl    `$0, %esi           # Start index
    movl    `$1000, %edx        # End index
    call    parallel_for_runtime # Call parallel runtime
    
    # Atomic operations
    lock addl `$1, global_counter(%rip)  # Atomic increment

"@
    }

    if ($EnableVectorize) {
        $asm += @"
    # Vectorized operations (SSE/AVX)
    movaps  vector_a(%rip), %xmm0    # Load 4 floats
    addps   vector_b(%rip), %xmm0    # Add 4 floats in parallel
    movaps  %xmm0, result(%rip)      # Store result

"@
    }

    # 优化相关代码
    switch ($OptLevel) {
        "1" {
            $asm += @"
    # O1 optimizations: Basic register allocation
    # Variables kept in registers when possible

"@
        }
        "2" {
            $asm += @"
    # O2 optimizations: Loop unrolling and instruction scheduling
    # Advanced register allocation with spill optimization

"@
        }
        "3" {
            $asm += @"
    # O3 optimizations: Aggressive inlining and vectorization
    # Cross-function optimization and loop vectorization

"@
        }
    }

    $asm += @"
    # Function epilogue
    movl    `$0, %eax           # Return 0
    addq    `$16, %rsp          # Restore stack
    popq    %rbp
    ret

# Data section
.section .data
global_counter: .long 0
vector_a: .float 1.0, 2.0, 3.0, 4.0
vector_b: .float 2.0, 2.0, 2.0, 2.0
result: .space 16

# BSS section
.section .bss
.comm buffer, 1024, 4

# End of generated assembly
"@

    return $asm
}

function Main {
    if ($Help -or -not $InputFile) {
        Show-Help
        return
    }

    if (-not $OutputFile) {
        $OutputFile = [System.IO.Path]::ChangeExtension($InputFile, ".s")
    }

    Write-Host "X86/X64 Parallel C Compiler (Demo Version)" -ForegroundColor Green
    Write-Host "===========================================" -ForegroundColor Green
    Write-Host ""

    if ($Verbose) {
        Write-Host "Input file:  $InputFile" -ForegroundColor Cyan
        Write-Host "Output file: $OutputFile" -ForegroundColor Cyan
        Write-Host "Optimization: O$OptLevel" -ForegroundColor Cyan
        Write-Host "Parallel: $OpenMP" -ForegroundColor Cyan
        Write-Host "Vectorize: $Vectorize" -ForegroundColor Cyan
        Write-Host ""
    }

    try {
        # 词法分析
        Write-Host "Phase 1: Lexical Analysis" -ForegroundColor Yellow
        if ($Verbose) { Write-Host "  Tokenizing source code..." }
        Start-Sleep -Milliseconds 100
        Write-Host "  ✓ Lexical analysis completed" -ForegroundColor Green

        # 语法分析
        Write-Host "Phase 2: Syntax Analysis" -ForegroundColor Yellow
        if ($Verbose) { Write-Host "  Building Abstract Syntax Tree..." }
        Start-Sleep -Milliseconds 150
        $analysis = Get-SourceAnalysis $InputFile
        Write-Host "  ✓ Syntax analysis completed" -ForegroundColor Green

        # 语义分析
        Write-Host "Phase 3: Semantic Analysis" -ForegroundColor Yellow
        if ($Verbose) { 
            Write-Host "  Type checking and symbol resolution..."
            Write-Host "  Found $($analysis.Functions.Count) functions"
            Write-Host "  Found $($analysis.Variables.Count) variables"
        }
        Start-Sleep -Milliseconds 200
        Write-Host "  ✓ Semantic analysis completed" -ForegroundColor Green

        # 代码生成
        Write-Host "Phase 4: Code Generation" -ForegroundColor Yellow
        if ($Verbose) { Write-Host "  Generating x86/x64 assembly code..." }
        Start-Sleep -Milliseconds 300
        
        $assembly = New-AssemblyCode $analysis $OptLevel $OpenMP $Vectorize
        $assembly | Out-File -FilePath $OutputFile -Encoding UTF8
        
        Write-Host "  ✓ Code generation completed" -ForegroundColor Green

        # 统计信息
        Write-Host ""
        Write-Host "Compilation Statistics:" -ForegroundColor Magenta
        Write-Host "======================" -ForegroundColor Magenta
        Write-Host "Source lines:     $($analysis.LineCount)"
        Write-Host "Functions:        $($analysis.Functions.Count)"
        Write-Host "Variables:        $($analysis.Variables.Count)"
        Write-Host "Has loops:        $($analysis.HasLoops)"
        Write-Host "Has parallel:     $($analysis.HasParallelFor)"
        Write-Host "Has atomic:       $($analysis.HasAtomic)"
        Write-Host "Output size:      $((Get-Content $OutputFile | Measure-Object -Line).Lines) lines"

        Write-Host ""
        Write-Host "✅ Compilation successful!" -ForegroundColor Green
        Write-Host "Generated assembly: $OutputFile" -ForegroundColor Green

        if ($Verbose) {
            Write-Host ""
            Write-Host "Generated Assembly Preview:" -ForegroundColor Cyan
            Write-Host "===========================" -ForegroundColor Cyan
            Get-Content $OutputFile | Select-Object -First 20 | ForEach-Object {
                Write-Host $_ -ForegroundColor Gray
            }
            if ((Get-Content $OutputFile).Count -gt 20) {
                Write-Host "... (truncated, see $OutputFile for full output)" -ForegroundColor DarkGray
            }
        }

    } catch {
        Write-Host ""
        Write-Host "❌ Compilation failed!" -ForegroundColor Red
        Write-Host "Error: $($_.Exception.Message)" -ForegroundColor Red
        return 1
    }
    
    return 0
}

# 运行主函数
Main
